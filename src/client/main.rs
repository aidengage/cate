mod pages;
mod sender;
use gdk::Display;
use gtk::prelude::*;
use gtk::{
    gdk, Application, ApplicationWindow, Box, CssProvider, Orientation, Stack, StackSwitcher,
};

// lazy_static used to be able to dynamically create global variables
// use this to store variables the user needs to input data for but
// the program needs throughout the client process
use lazy_static::lazy_static;
// probably do not need it for stuff like the push, pull, and links dirs

use pages::{file::FilePage, home::HomePage, setting::SettingPage};
use std::fs::File;
use std::net::Ipv4Addr;
use std::path::Path;
use std::string::ToString;
use std::sync::Arc;
use std::sync::Mutex;
use std::{env, fs, io};

lazy_static! {

    // lazy_static string to establish the root of the project directory
    // used to base the rest of the directories from
    static ref ROOT_DIR: String = env::var("PROJECT_ROOT").unwrap_or_else(|_| env::current_dir()
        .unwrap()
        .to_str()
        .unwrap()
        .to_string());

    // lazy_static string to represent the PULL_DIR
    // where the client places files dragged onto the application
    // to be sent out to the server
    static ref PULL_DIR: String = Path::new(&*ROOT_DIR)
        // refactor to remove PULL_DIR and PUSH_DIR
        .join("pull/")
        .to_str()
        .unwrap()
        .to_string();

    // lazy_static string to represent the PUSH_DIR
    // where the client will look to send files out
    static ref PUSH_DIR: String = Path::new(&*ROOT_DIR)
        // refactor to remove PULL_DIR and PUSH_DIR
        .join("push/")
        .to_str()
        .unwrap()
        .to_string();

    // lazy_static string to represent the LINK_DIR
    // where the client looks to store links generated by the server and client
    // to be displayed in the application
    static ref LINK_DIR: String = Path::new(&*ROOT_DIR)
        // i dont think i need this anymore
        .join("assets/")
        .to_str()
        .unwrap()
        .to_string();

    // lazy_static string to represent the LINK_FILE
    // the actual file to store the links generated by the server and client
    static ref LINK_FILE: String = Path::new(&*ROOT_DIR)
        .join("assets/links.txt")
        .to_str()
        .unwrap()
        .to_string();

    // initializes an empty/new lazy_static string to represent USER_DOMAIN
    // user will input a domain to point to their server if they have a domain
    static ref USER_DOMAIN: Arc<Mutex<String>> = Arc::new(Mutex::new(String::new()));

    // initializes an ampty/new lazy_static ipv4addr to represent USER_IP
    // the user needs to input an ip address to point to their server
    // this is required and needs lazy implementation to allow for
    // on the fly server changes
    static ref USER_IP: Arc<Mutex<Ipv4Addr>> = Arc::new(Mutex::new(Ipv4Addr::new(0, 0, 0, 0)));
}

// default port of carbon and many other services
const PORT: u16 = 8000;
// need to change this to something that actually isnt common

// APP_ID needed for gtk and the chosen string follows the correct naming conventions
const APP_ID: &str = "com.aidengage.carbon";

////////////////////////////////////////////
//         some weird gtk stuff          //
////////////////////////////////////////////

// creates a struct to build the initial application structure
// need to start with an ApplicationWindow at least
// page_stack stores the different pages for the application, located in /pages/ folder
pub struct Carbon {
    pub window: ApplicationWindow,
    pub page_stack: Stack,
}

//
impl Carbon {
    pub fn new(app: &Application) -> Self {
        // creates the default window carbon uses to exist as an application
        // setting the title of the menubar with set_title and size with set_default_size
        let window = ApplicationWindow::new(app);
        window.set_title(Some("Carbon"));
        window.set_default_size(350, 200);

        // gtk uses a stack to store each page for your application, it only shows
        // one child at a time and the user cant change which child is shown
        let page_stack = Stack::new();

        // a stack switcher is required to be able to change which child is shown
        // typically used for tabs and navigation around the application
        let stack_switcher = StackSwitcher::new();
        stack_switcher.set_stack(Some(&page_stack));

        // creates the default landing page for the application
        // i believe is the ip and domain page
        let main_box = Box::new(Orientation::Vertical, 10);
        // see if orientation matters actually
        main_box.append(&stack_switcher);
        main_box.append(&page_stack);

        // sets the default window for the user by adding it as a child
        // to the window created earlier
        window.set_child(Some(&main_box));

        Self { window, page_stack }
    }

    pub fn init(&self) {
        // creates home, file, and setting (landing) pages based on the page_stack
        let home = HomePage::new(&self.page_stack);
        let file = FilePage::new(&self.page_stack);
        let setting = SettingPage::new(&self.page_stack);

        // adds each page just created to the page_stack in order
        self.page_stack
            .add_named(&setting.vbox_settings, Some("setting-page"));
        self.page_stack.add_named(&home.overlay, Some("home-page"));
        self.page_stack
            .add_named(&file.vbox_files, Some("file-page"));
    }
}

fn main() {
    // runs create_files_dirs function to create all the necessary
    // files and directories required for carbon to function
    create_files_dirs().expect("could not create directories and files");

    // officially builds the application and sets its id
    let app = Application::builder().application_id(APP_ID).build();

    // applies the css file in the working directory to style carbon correctly
    // onces applied, the ui is created and the app is run
    app.connect_startup(|_| apply_css());
    app.connect_activate(create_ui);
    app.run();
}

// big stupid function i can probably optimize to work better
// correctly check for directories and files and do what is needed
fn create_files_dirs() -> io::Result<()> {
    match fs::create_dir(&*PULL_DIR) {
        Ok(_) => println!("pull dir created"),
        Err(e) if e.kind() == io::ErrorKind::AlreadyExists => {
            println!("dir already exists");
        }
        Err(e) => return Err(e),
    }
    match fs::create_dir_all(&*PUSH_DIR) {
        Ok(_) => println!("push dir created"),
        Err(e) if e.kind() == io::ErrorKind::AlreadyExists => {
            println!("dir already exists");
        }
        Err(e) => return Err(e),
    }
    match fs::create_dir(&*LINK_DIR) {
        Ok(_) => {
            println!("link dir created");
            File::create(LINK_FILE.clone())?;
        }
        Err(e) if e.kind() == io::ErrorKind::AlreadyExists => {
            println!("dir already exists");
            // File::create(LINK_FILE.clone())?;
        }
        Err(e) => return Err(e),
    }
    Ok(())
}

// boilerplate create_ui function, does what it needs
// required to build the ui elements
fn create_ui(app: &Application) {
    // Create and initialize the app
    let app = Carbon::new(app);
    app.init();
    app.window.present();
}

// boilerplate apply_css function, needed to style the application
fn apply_css() {
    // need a styling variable to store the css information from
    // client.css
    let styling = CssProvider::new();

    // takes the client.css file that is within the directory and
    // loads it onto the application with load_from_string
    styling.load_from_string(include_str!("./client.css"));

    // this connects the display information with the styling variable
    // i applied the client.css to
    gtk::style_context_add_provider_for_display(
        &Display::default().expect("Couldn't get default display"),
        &styling,
        gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
    );
}
